MODULE Process;
    IMPORT Fox32ROM, Allocator, FXF, VFS;

    ASM "Process.asm";

    CONST MAX_PROCESSES = 128;
          PROCESS_SIZE = 24;

    CONST STATE_UNUSED = 0;
          STATE_DEAD = 1;
          STATE_RUNNABLE = 2;
          STATE_RUNNING = 3;
          STATE_SLEEPING = 4;

    TYPE Process = RECORD
        id: INT;
        instructionPtr: PTR;
        stackPtr: PTR;
        codeBlockPtr: PTR;
        stackBlockPtr: PTR;
        state: INT;
    END;

    VAR currentProcess: POINTER TO Process;
        processes: ARRAY MAX_PROCESSES OF POINTER TO Process;
        schedulerProcess: Process;

    PROCEDURE InitializeScheduler();
    BEGIN
        schedulerProcess.instructionPtr := PTROF(Scheduler);
        schedulerProcess.stackPtr := Allocate(0FFFFH) + 0FFFFH;
        currentProcess := 0;
    END;

    PROCEDURE NewProcess(fileName: POINTER TO CHAR; diskId: INT;): INT;
    VAR id: INT;
        fileStruct: FileOrStream;
        fileSize: INT;
        instructionPtr: PTR;
        codeBlockPtr: PTR;
        stackPtr: PTR;
        stackBlockPtr: PTR;
        processPtr: POINTER TO Process;
    BEGIN
        (* find an unused ID, or fail if none found *)
        id := FindUnusedProcess();
        IF id = 0FFFFFFFFH THEN
            RETURN(0);
        END;

        (* open the file and get its size *)
        IF Open(fileName, diskId, PTROF(fileStruct)) = 0 THEN
            RETURN(0);
        END;
        fileSize := GetSize(PTROF(fileStruct));

        (* allocate a block of memory for the process code *)
        codeBlockPtr := Allocate(fileSize);
        IF codeBlockPtr = 0 THEN
            RETURN(0);
        END;

        (* read the file into the allocated block of memory *)
        Read(fileSize, PTROF(fileStruct), codeBlockPtr);

        (* allocate a 64KB block of memory for the process stack *)
        stackBlockPtr := Allocate(0FFFFH);
        IF stackBlockPtr = 0 THEN
            Free(codeBlockPtr);
            RETURN(0);
        END;
        stackPtr := stackBlockPtr + 0FFFFH;

        (* allocate a block of memory for the process record *)
        processPtr := Allocate(PROCESS_SIZE);
        IF processPtr = 0 THEN
            Free(codeBlockPtr);
            Free(stackBlockPtr);
            RETURN(0);
        END;

        (* relocate the binary *)
        instructionPtr := RelocateFXF(codeBlockPtr);
        IF instructionPtr = 0 THEN
            Free(codeBlockPtr);
            Free(stackBlockPtr);
            Free(processPtr);
            RETURN(0);
        END;

        (* finally, set all of the values in the process record *)
        processPtr^.id := id;
        processPtr^.instructionPtr := instructionPtr;
        processPtr^.stackPtr := stackPtr;
        processPtr^.codeBlockPtr := codeBlockPtr;
        processPtr^.stackBlockPtr := stackBlockPtr;
        processPtr^.state := STATE_RUNNABLE;
        processes[id] := processPtr;

        RETURN(1);
    END;

    EXTERN PROCEDURE YieldProcess: INT;
    EXTERN PROCEDURE SwitchProcess: INT;

    PROCEDURE Scheduler();
    VAR i: INT;
        tempProcess: POINTER TO Process;
    BEGIN
        WHILE 1 DO
            i := 0;
            WHILE i <| MAX_PROCESSES DO
                tempProcess := processes[i];
                IF tempProcess = 0 THEN
                    i := i + 1;
                    CONTINUE();
                END;
                IF tempProcess^.state # STATE_RUNNABLE THEN
                    i := i + 1;
                    CONTINUE();
                END;

                (* mark the process as running and switch to it, setting it as the current process *)
                tempProcess^.state := STATE_RUNNING;
                SwitchProcess(tempProcess);

                (* once we reach this point, the process has switched back here *)
                (* mark it as runnable *)
                tempProcess^.state := STATE_RUNNABLE;
                i := i + 1;
            END;
        END;
    END;

    PROCEDURE FindUnusedProcess(): INT;
    VAR i: INT;
    BEGIN
        i := 0;
        WHILE i <| MAX_PROCESSES DO
            IF processes[i] = 0 THEN
                RETURN(i);
            END;
            i := i + 1;
        END;
        RETURN(0FFFFFFFFH);
    END;
END.

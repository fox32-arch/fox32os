#ASM [
    pop a0 // stream_local
    pop a1 // arg0
    call Main
    call EndCurrentTask
]

#DEFINE BLD_BITS 32
#DEFINE ARCHITECTURE "fox32"
#INCLUDE "sys/rtl.hjk"
#INCLUDE "sys/os.hjk"

#DEFINE MAX_WINDOWS 16
#DEFINE DOUBLE_CLICK_TICKS 500

STRUCT Icon
    Name : UBYTE[13],
    Pos : Position,
    Widget : ButtonWidget,
END

STRUCT IconWindow
    Window : Window,
    Width : UINT,
    Height : UINT,
    Icon : Icon[31], // RYFS has a max of 31 files per directory
    NumIcons : UBYTE,
    Path : UBYTE[256], // 256 is an arbitrary size. should hopefully be enough
    Disk : UBYTE,
    ClickTimeMax : ULONG,
    ClickIcon : UBYTE,
END

text_stream : ^File = NULLPTR
windows : ^IconWindow[MAX_WINDOWS]

EXTERN FN GetTick() : ULONG
#ASM [
GetTick:
.global GetTick
    in a3, 0x80000706
    ret
]

FN (RtlPrintCallbackF) RtljPrintCallback(
    IN byte : UBYTE,
    IN context : ^VOID,
)
    IF text_stream != 0 THEN
        buffer : UBYTE[1]
        buffer[0] = byte
        Write(text_stream, &buffer[0], 1)
    END
END
FN RtljLockStream(IN handle : ^VOID) : UWORD
    // dummy function to keep the compiler happy
END
FN RtljUnlockStream(
    IN handle : ^VOID,
    IN lockcontext : UWORD,
)
    // dummy function to keep the compiler happy
END

FN Exit()
    EndCurrentTask()
END

FN Error(IN error_string : ^UBYTE)
    RtlPrint(error_string)
    RtlPrint("\n")
    // TODO: close all windows
    Exit()
END

FN Initialize(
    IN stream_local : ^File,
    IN path : ^UBYTE,
)
    text_stream = stream_local
END

FN RenderWindow(
    IN windowNumber : UWORD,
    IN drawEdge : UBYTE,
)
    window : ^IconWindow = windows[windowNumber]
    IF drawEdge THEN
        DrawFilledRectangleToOverlay(0, 16, window^.Width, window^.Height, 0xFF000000, window^.Window.Overlay)
    END
    DrawFilledRectangleToOverlay(1, 17, window^.Width - 2, window^.Height - 2, 0xFFFFFFFF, window^.Window.Overlay)

    tempBuf : UBYTE[16]
    RtlFormat(&tempBuf[0], 16, "%d files", window^.NumIcons)
    DrawStrToOverlay(&tempBuf[0], 4, 17, 0xFF000000, 0xFFFFFFFF, window^.Window.Overlay)

    i := 0
    WHILE i < window^.NumIcons DO
        IF i == window^.ClickIcon THEN
            window^.Icon[i].Widget.FgColor = 0xFFDDDDDD
            window^.Icon[i].Widget.BgColor = 0xFF000000
        ELSE
            window^.Icon[i].Widget.FgColor = 0xFF000000
            window^.Icon[i].Widget.BgColor = 0xFFDDDDDD
        END
        i += 1
    END

    DrawWidgetsToWindow(&window^.Window)
END

FN OpenWindow(IN path : ^UBYTE) : UWORD
    w := 0
    WHILE w < MAX_WINDOWS DO
        IF windows[w] == NULLPTR THEN BREAK END
        w += 1
    END
    IF w == MAX_WINDOWS THEN
        // no windows free
        RETURN NULLPTR
    END

    windows[w] = AllocateMemory(SIZEOF IconWindow)
    IF windows[w] == 0 THEN Error("Failed to allocate for new window") END

    CopyString(path, &windows[w]^.Path)
    windows[w]^.Disk = path[0] - '0' // FIXME: this is stupid

    // prepare the window

    files : UBYTE[341]
    window : ^IconWindow = windows[w]
    tempFile : File
    directory := Open(path, window^.Disk, &tempFile)
    IF directory == 0 THEN
        buffer : UBYTE[256]
        RtlFormat(&buffer[0], 256, "Can't open directory %s", path)
        Error(&buffer[0])
    END
    window^.NumIcons = GetFileList(&files[0], window^.Disk, directory)

    window^.ClickIcon = 0xFF // no icon clicked

    IF window^.NumIcons > 5 THEN
        window^.Width = 96 * 5
    ELSE
        window^.Width = window^.NumIcons * 96
    END
    window^.Height = ((window^.NumIcons / 5) + 1) * 64 + 8

    i := 0
    nameOffset := 0
    WHILE i < window^.NumIcons DO
        // copy the file name and shorten it as needed
        CopyMemoryBytes(&files[nameOffset], &window^.Icon[i].Name[0], 8)
        j := 7
        WHILE j > 0 DO
            IF window^.Icon[i].Name[j] != ' ' THEN BREAK END
            j -= 1
            // TODO: handle error if no non-space char found
        END
        window^.Icon[i].Name[j+1] = '.'
        CopyMemoryBytes(&files[nameOffset+8], &window^.Icon[i].Name[j+2], 3)
        window^.Icon[i].Name[j+5] = 0

        window^.Icon[i].Pos.X = ((i % 5) * 96) + 32
        window^.Icon[i].Pos.Y = ((i / 5) * 64) + 32

        IF i == window^.NumIcons - 1 THEN
            window^.Icon[i].Widget.Next = 0
        ELSE
            window^.Icon[i].Widget.Next = &window^.Icon[i+1].Widget
        END
        window^.Icon[i].Widget.Id = i
        window^.Icon[i].Widget.Type = WIDGET_TYPE_BUTTON
        window^.Icon[i].Widget.Text = &window^.Icon[i].Name[0]
        window^.Icon[i].Widget.FgColor = 0xFF000000
        window^.Icon[i].Widget.BgColor = 0xFFDDDDDD
        window^.Icon[i].Widget.Width = 32
        window^.Icon[i].Widget.Height = 48
        window^.Icon[i].Widget.X = window^.Icon[i].Pos.X
        window^.Icon[i].Widget.Y = window^.Icon[i].Pos.Y

        nameOffset += 11
        i += 1
    END

    NewWindow(
        &window^.Window,
        &window^.Path[0],
        window^.Width,
        window^.Height,
        64 + (w * 20),
        64 + (w * 20),
        0,
        &window^.Icon[0].Widget
    )
    RenderWindow(w, TRUE)
    RETURN w
END

FN CloseWindow(IN windowNumber : UWORD)
    IF windows[windowNumber] != NULLPTR THEN
        DestroyWindow(&windows[windowNumber]^.Window)
        FreeMemory(windows[windowNumber])
        windows[windowNumber] = NULLPTR
    END
END

FN HandleMouseClick(
    IN windowNumber : UWORD,
    IN x : UINT,
    IN y : UINT,
)
    IF y < 16 THEN
        // user clicked title bar
        IF x < 8 THEN
            // user clicked close button
            CloseWindow(windowNumber)
            LEAVE
        END

        // otherwise, start dragging the window
        StartDraggingWindow(&windows[windowNumber]^.Window)
        LEAVE
    END

    HandleWidgetClick(&windows[windowNumber]^.Window, x, y)
END

FN HandleButtonClick(
    IN windowNumber : UWORD,
    IN buttonId : UWORD,
)
    IF windows[windowNumber]^.ClickIcon == buttonId THEN
        // the last-clicked icon was this one
        // check if too much time has passed
        IF windows[windowNumber]^.ClickTimeMax < GetTick() THEN
            // too much time passed, reset the timer and return
            windows[windowNumber]^.ClickTimeMax = GetTick() + DOUBLE_CLICK_TICKS
            LEAVE
        END
        // otherwise, reset the time and icon and continue
        windows[windowNumber]^.ClickTimeMax = 0
        windows[windowNumber]^.ClickIcon = 0xFF
    ELSE
        // a new button was just clicked, set up the timer and return
        windows[windowNumber]^.ClickTimeMax = GetTick() + DOUBLE_CLICK_TICKS
        windows[windowNumber]^.ClickIcon = buttonId
        RenderWindow(windowNumber, FALSE)
        LEAVE
    END

    // build up the new path string
    // there is probably a much better way to do this
    nameLen := StringLength(&windows[windowNumber]^.Icon[buttonId].Name[0])
    pathLen := StringLength(&windows[windowNumber]^.Path[0])
    concatPath : UBYTE[256]
    separator : UBYTE[2]
    IF windows[windowNumber]^.Path[pathLen - 1] == '/' THEN
        separator[0] = 0
    ELSE
        separator[0] = '/'
        separator[1] = 0
    END
    RtlFormat(&concatPath[0], 256, "%s%s%s",
        &windows[windowNumber]^.Path[0],
        &separator[0],
        &windows[windowNumber]^.Icon[buttonId].Name[0]
    )
    IF CompareString(&windows[windowNumber]^.Icon[buttonId].Name[nameLen - 3], "dir") THEN
        OpenWindow(&concatPath[0])
    ELSE
        LaunchFxfFromDisk(&concatPath[0], windows[windowNumber]^.Disk, 0, 0, 0, 0, 0)
    END
END

FN Main(
    IN stream_local : ^File,
    IN arg0 : ^UBYTE,
)
    Initialize(stream_local, arg0)
    running := TRUE

    testWindow := OpenWindow("0:/")

    WHILE running == TRUE DO
        w := 0
        openWindows := 0
        WHILE w < MAX_WINDOWS DO
            IF windows[w] == NULLPTR THEN w += 1 CONTINUE END
            openWindows += 1
            e : Event
            GetNextWindowEvent(&windows[w]^.Window, &e)
            IF e.Type == EVENT_TYPE_MOUSE_CLICK THEN
                HandleMouseClick(w, e.Body.Pos.X, e.Body.Pos.Y)
            ELSEIF e.Type == EVENT_TYPE_BUTTON_CLICK THEN
                HandleButtonClick(w, e.Body.Parameters[0])
            END
            YieldTask()
            w += 1
        END
        IF openWindows == 0 THEN
            running = FALSE
        END
    END

    Exit()
END

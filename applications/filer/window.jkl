#DEFINE BLD_BITS 32
#DEFINE ARCHITECTURE "fox32"
#INCLUDE "sys/rtl.hjk"
#INCLUDE "sys/os.hjk"

#INCLUDE "window.hjk"
#INCLUDE "desktop.hjk"
#INCLUDE "filetype.hjk"

EXTERN FN Error(IN error_string : ^UBYTE)
EXTERN windows : ^IconWindow[]
EXTERN icons_graphics : ^UBYTE

EXTERN menu_bar : Menu
#ASM [
menu_bar:
.global menu_bar
    // number of menus
    .db 1
    // "items" and "name" table pairs for each menu
    .dp menu_file_items
    .dp menu_file_name
menu_file_name:
    // length, ASCII string, null
    .db 4 .ds "File" .db 0
menu_file_items:
    // number of menu items
    .db 2
    // width of menu, generally 2 greater than the longest menu item
    .db 13
    // length, ASCII string, null for each menu item
    .db 6  .ds "New..." .db 0
    .db 11 .ds "Get Info..." .db 0
]

FN RenderWindow(
    IN windowNumber : UWORD,
    IN drawEdge : UBYTE,
)
    window : ^IconWindow = windows[windowNumber]
    IF window^.WindowType == WINDOW_TYPE_DESKTOP THEN
        RenderDesktop(windowNumber)
        LEAVE
    END

    IF drawEdge THEN
        DrawFilledRectangleToOverlay(0, 16, window^.Width, window^.Height, 0xFF000000, window^.Window.Overlay)
    END
    DrawFilledRectangleToOverlay(1, 17, window^.Width - 2, window^.Height - 2, WINDOW_BG_COLOR, window^.Window.Overlay)

    tempBuf : UBYTE[16]
    RtlFormat(&tempBuf[0], 16, "%d files", window^.NumIcons)
    DrawStrToOverlay(&tempBuf[0], 4, 17, 0xFF000000, 0xFFFFFFFF, window^.Window.Overlay)

    i := 0
    WHILE i < window^.NumIcons DO
        IF i == window^.ClickIcon THEN
            window^.Icon[i].Widget.FgColor = UNSELECTED_BG_COLOR
            window^.Icon[i].Widget.BgColor = SELECTED_BG_COLOR
        ELSE
            window^.Icon[i].Widget.FgColor = SELECTED_BG_COLOR
            window^.Icon[i].Widget.BgColor = UNSELECTED_BG_COLOR
        END
        i += 1
    END

    IF window^.NumIcons > 0 THEN
        DrawWidgetsToWindow(&window^.Window)
    END

    i = 0
    WHILE i < window^.NumIcons DO
        extIndex := StringLength(&window^.Icon[i].Name[0]) - 3
        IF window^.Icon[i].Graphic != NULLPTR THEN
            tempGraphic : ULONG[32*32]
            CopyMemoryWords(&window^.Icon[i].Graphic[0], &tempGraphic[0], 32*32)
            // replace transparent pixels with the window background color
            j := 0
            WHILE j < 1024 DO
                IF tempGraphic[j] & 0xFF000000 == 0 THEN
                    tempGraphic[j] = WINDOW_BG_COLOR
                END
                j += 1
            END
            SetTilemap(&tempGraphic[0], 32, 32)
            DrawTileToOverlay(0, window^.Icon[i].Pos.X, window^.Icon[i].Pos.Y, window^.Window.Overlay)
        ELSEIF icons_graphics != NULLPTR THEN
            iconDataPtr : ^ULONG = GetResource(icons_graphics, &window^.Icon[i].Name[extIndex], 4096)
            IF iconDataPtr == NULLPTR THEN
                iconDataPtr = GetResource(icons_graphics, "msc", 4096)
            END
            IF iconDataPtr != NULLPTR THEN
                // replace transparent pixels with the window background color
                j := 0
                WHILE j < 1024 DO
                    IF iconDataPtr[j] & 0xFF000000 == 0 THEN
                        iconDataPtr[j] = WINDOW_BG_COLOR
                    END
                    j += 1
                END
                SetTilemap(iconDataPtr, 32, 32)
                DrawTileToOverlay(0, window^.Icon[i].Pos.X, window^.Icon[i].Pos.Y, window^.Window.Overlay)
                FreeMemory(iconDataPtr)
            END
        END
        i += 1
    END
END

FN OpenWindow(IN path : ^UBYTE) : UWORD
    w := 0
    WHILE w < MAX_WINDOWS DO
        IF windows[w] == NULLPTR THEN BREAK END
        w += 1
    END
    IF w == MAX_WINDOWS THEN
        // no windows free
        RETURN NULLPTR
    END

    windows[w] = AllocateMemory(SIZEOF IconWindow)
    IF windows[w] == 0 THEN Error("Failed to allocate for new window") END
    windows[w]^.WindowType = WINDOW_TYPE_BROWSER

    CopyString(path, &windows[w]^.Path)
    windows[w]^.Disk = path[0] - '0' // FIXME: this is stupid

    // prepare the window

    files : UBYTE[341]
    window : ^IconWindow = windows[w]
    tempFile : File
    directory := Open(path, window^.Disk, &tempFile)
    IF directory == 0 THEN
        buffer : UBYTE[256]
        RtlFormat(&buffer[0], 256, "Can't open directory %s", path)
        FreeMemory(windows[w])
        windows[w] = NULLPTR
        Error(&buffer[0])
    END
    window^.NumIcons = GetFileList(&files[0], window^.Disk, directory)

    window^.ClickIcon = 0xFF // no icon clicked

    IF window^.NumIcons > 5 THEN
        window^.Width = 96 * 5
    ELSE
        IF window^.NumIcons == 0 THEN
            window^.Width = 96
        ELSE
            window^.Width = window^.NumIcons * 96
        END
    END
    window^.Height = ((window^.NumIcons / 5) + 1) * 64 + 8

    i := 0
    nameOffset := 0
    WHILE i < window^.NumIcons DO
        // copy the file name and shorten it as needed
        CopyMemoryBytes(&files[nameOffset], &window^.Icon[i].Name[0], 8)
        j := 7
        WHILE j > 0 DO
            IF window^.Icon[i].Name[j] != ' ' THEN BREAK END
            j -= 1
            // TODO: handle error if no non-space char found
        END
        window^.Icon[i].Name[j+1] = '.'
        CopyMemoryBytes(&files[nameOffset+8], &window^.Icon[i].Name[j+2], 3)
        window^.Icon[i].Name[j+5] = 0
        CopyString(&window^.Icon[i].Name[0], &window^.Icon[i].Text[0])

        window^.Icon[i].Graphic = NULLPTR

        // if this is an FXF file, handle APP header if it exists
        IF CompareMemory(&window^.Icon[i].Name[j+2], "fxf", 3) THEN
            FillFxfAppData(window, i)
        END

        window^.Icon[i].IsDisk = FALSE

        window^.Icon[i].Pos.X = ((i % 5) * 96) + 32
        window^.Icon[i].Pos.Y = ((i / 5) * 64) + 32

        IF i == window^.NumIcons - 1 THEN
            window^.Icon[i].Widget.Next = 0
        ELSE
            window^.Icon[i].Widget.Next = &window^.Icon[i+1].Widget
        END
        window^.Icon[i].Widget.Id = i
        window^.Icon[i].Widget.Type = WIDGET_TYPE_BUTTON
        window^.Icon[i].Widget.Text = &window^.Icon[i].Text[0]
        window^.Icon[i].Widget.FgColor = 0xFF000000
        window^.Icon[i].Widget.BgColor = 0xFFDDDDDD
        window^.Icon[i].Widget.Width = 32
        window^.Icon[i].Widget.Height = 48
        window^.Icon[i].Widget.X = window^.Icon[i].Pos.X
        window^.Icon[i].Widget.Y = window^.Icon[i].Pos.Y

        nameOffset += 11
        i += 1
    END

    NewWindow(
        &window^.Window,
        &window^.Path[0],
        window^.Width,
        window^.Height,
        64 + (w * 20),
        64 + (w * 20),
        &menu_bar,
        &window^.Icon[0].Widget
    )
    RenderWindow(w, TRUE)
    RETURN w
END

FN CloseWindow(IN windowNumber : UWORD)
    IF windows[windowNumber] != NULLPTR THEN
        DestroyWindow(&windows[windowNumber]^.Window)
        i := 0
        WHILE i < 31 DO
            IF windows[windowNumber]^.Icon[i].Graphic != NULLPTR THEN
                FreeMemory(windows[windowNumber]^.Icon[i].Graphic)
                windows[windowNumber]^.Icon[i].Graphic = NULLPTR
            END
            i += 1
        END
        FreeMemory(windows[windowNumber])
        windows[windowNumber] = NULLPTR
    END
END
